<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <!--

    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details

    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>twgl.js - twgl cube</title>
    <style>
      body {
          margin: 0;
          font-family: monospace;
      }
      canvas {
          display: block;
          width: 100vw;
          height: 100vh;
      }
      #b {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="b"><a href="http://twgljs.org">twgl.js</a> - twgl-cube</div>
  </body>

  <!------------------- 버텍스 셰이더 ------------------->
  <script id="vs" type="notjs">
    // uniform: 모든 버텍스에 대해 동일하게 들어오는 입력
    uniform mat4 u_worldViewProjection;
    uniform mat4 u_world;

    // attribute: 각 버텍스마다 다른 입력
    attribute vec4 position;
    attribute vec2 texcoord;
    attribute vec3 color;

    // varying: 프래그먼트 셰이더로 전달하기 위한 출력
    varying vec4 v_color;
    varying vec2 v_texCoord;

    void main() {
      v_color = vec4(color.rgb, 1.0);
      v_texCoord = texcoord;

      // 3D API에 전달하는 출력. 프로젝션 변환까지 마친 상태이다.
      gl_Position = u_worldViewProjection * position;
    }
  </script>

  <!------------------- 프래그먼트(픽셀) 셰이더 ------------------->
  <script id="fs" type="notjs">
    precision mediump float;

    // uniform: 모든 프래그먼트에 대해 동일하게 들어오는 입력
    // (지금은 없다)

    // varying: 프래그먼트 셰이더로부터 받은 입력
    varying vec4 v_color;

    void main() {
      // 3D API에 전달하는 출력. 이 프래그먼트(픽셀)의 최종 컬러를 지정한다.
      gl_FragColor = v_color;
    }
  </script>

  <!------------------- 소스 코드 ------------------->
  <script type="module">
    import * as twgl from '../twgl-full.module.js';
    import { MeshBuilder } from './MeshBuilder.js';

    const m4 = twgl.m4; // https://twgljs.org/docs/module-twgl_m4.html
    const v3 = twgl.v3; // https://twgljs.org/docs/module-twgl_v3.html
    const gl = document.querySelector("#c").getContext("webgl");
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

    const arrays = {
      position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],
      color:    [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],
      indices:  [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],
    };

    function rgb(r, g, b) { return [ r, g, b, 1.0 ]}

    function buildMesh() {
      const mb = new MeshBuilder();

      let vertex1 = mb.addVertex(v3.create(0, 0, 1), rgb(1, 0, 0, 1));
      let vertex2 = mb.addVertex(v3.create(1, 0, -1), rgb(0, 1, 0, 1));
      let vertex3 = mb.addVertex(v3.create(-1, 0, -1), rgb(0, 0, 1, 1));
      mb.addTriangle(vertex1, vertex2, vertex3);

      return twgl.createBufferInfoFromArrays(gl, mb.getArrays());
    }

    const bufferInfo = buildMesh();
    const uniforms = {
    };
    
    function render(time) {
      time *= 0.001;
      twgl.resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const fov = 45 * Math.PI / 180;
      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
      const zNear = 0.1;
      const zFar = 100;
      const projection = m4.perspective(fov, aspect, zNear, zFar);
      const eye = [2, 8, -12];
      const target = [0, 0, 0];
      const up = [0, 1, 0];

      const camera = m4.lookAt(eye, target, up);
      const view = m4.inverse(camera);
      const viewProjection = m4.multiply(projection, view);
      const world = m4.rotationY(/*time*/0);

      uniforms.u_viewInverse = camera;
      uniforms.u_world = world;
      uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(world));
      uniforms.u_worldViewProjection = m4.multiply(viewProjection, world);

      // 메시를 그린다
      gl.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, uniforms);
      gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

  </script>
</html>


