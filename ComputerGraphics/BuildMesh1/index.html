<!DOCTYPE html>
<html>

<head>
    <meta charset="utf8">
    <!--

    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details

    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>twgl.js - twgl cube</title>
    <style>
        body {
            margin: 0;
            font-family: monospace;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #text {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 2;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="text" style='background:#efefef;'></div>
</body>

<!------------------- 버텍스 셰이더 ------------------->
<script id="vs" type="notjs">
    // uniform: 모든 버텍스에 대해 동일하게 들어오는 입력
    uniform mat4 u_worldViewProjection;

    // attribute: 각 버텍스마다 다른 입력
    attribute vec4 position;
    attribute vec3 color;

    // varying: 프래그먼트 셰이더로 전달할 출력
    varying vec4 v_color;

    void main() {
        v_color = vec4(color.rgb, 1.0);

        // 3D API에 전달하는 출력
        gl_Position = u_worldViewProjection * position;
    }
  </script>

<!------------------- 프래그먼트(픽셀) 셰이더 ------------------->
<script id="fs" type="notjs">
    precision mediump float;

    // uniform: 모든 프래그먼트에 대해 동일하게 들어오는 입력
    // (지금은 없다)

    // varying: 프래그먼트 셰이더로부터 받은 입력
    varying vec4 v_color;

    void main() {
        // 3D API에 전달하는 출력. 이 프래그먼트(픽셀)의 최종 컬러를 지정한다.
        gl_FragColor = v_color;
    }
</script>

<!------------------- 버텍스 셰이더 ------------------->
<script id="vsDebugDisplay" type="notjs">
    uniform mat4 u_worldViewProjection;
    attribute vec4 position;
    attribute vec3 color;
    varying vec4 v_color;

    void main() {
        v_color = vec4(color.rgb, 1.0);
        gl_Position = u_worldViewProjection * position;
    }
</script>

<!------------------- 프래그먼트(픽셀) 셰이더 ------------------->
<script id="fsDebugDisplay" type="notjs">
    precision mediump float;
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }
</script>

<!------------------- 소스 코드 ------------------->
<script type="module">
    import * as twgl from '../twgl-full.module.js';
    import * as M from './MathHelper.mjs';
    import { Mesh } from './Mesh.mjs';
    import { Lines } from './Lines.mjs';

    const m4 = twgl.m4; // https://twgljs.org/docs/module-twgl_m4.html
    const v3 = twgl.v3; // https://twgljs.org/docs/module-twgl_v3.html
    const gl = document.querySelector("#canvas").getContext("webgl");
    const text = document.querySelector("#text");
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);
    const debugDisplayProgramInfo = twgl.createProgramInfo(gl, ["vsDebugDisplay", "fsDebugDisplay"]);

    function rgb(r, g, b) { return [r, g, b, 1.0] }

    function buildMesh() {
        const mesh = new Mesh();

        let vertex1 = mesh.addVertex(v3.create(0, 0, 1), rgb(1, 0, 0));
        let vertex2 = mesh.addVertex(v3.create(1, 0, -1), rgb(0, 1, 0));
        let vertex3 = mesh.addVertex(v3.create(-1, 0, -1), rgb(0, 0, 1));
        mesh.addTriangle(vertex1, vertex2, vertex3);

        return mesh;
    }

    const mesh = buildMesh();
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, mesh.arrays);

    const screenMousePos = v3.create(1000, 0, -1);
    gl.canvas.addEventListener('mousemove', (e) => {
        const rect = gl.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        screenMousePos[0] = x / rect.width * 2 - 1;
        screenMousePos[1] = y / rect.height * -2 + 1;
    });

    const uniforms = {
    };

    function render(time) {
        time *= 0.001;
        twgl.resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const fov = 45 * Math.PI / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100;
        const projection = m4.perspective(fov, aspect, zNear, zFar);
        const eye = [2, 8, -12];
        const target = [0, 0, 0];
        const up = [0, 1, 0];

        const world = m4.rotationY(time * 1);
        const camera = m4.lookAt(eye, target, up);
        const view = m4.inverse(camera);
        const viewProjection = m4.multiply(projection, view);
        const worldViewProjection = m4.multiply(viewProjection, world);
        const invWorldViewProjection = m4.inverse(worldViewProjection);
        const invWorld = m4.inverse(world);

        uniforms.u_viewInverse = camera;
        uniforms.u_world = world;
        uniforms.u_worldInverseTranspose = m4.transpose(invWorld);
        uniforms.u_worldViewProjection = worldViewProjection;

        // 메시를 그린다
        gl.useProgram(programInfo.program);
        twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
        twgl.setUniforms(programInfo, uniforms);
        gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);

        // 마우스 커서는 2차원 화면에서의 점 하나를 나타내는데
        // 이것을 3차원 공간으로 옮기면 선이 된다.
        // 선에서 가장 가까운 버텍스를 찾자.
        screenMousePos[2] = -1;
        const worldMousePos1 = m4.transformPoint(invWorldViewProjection, screenMousePos);
        screenMousePos[2] = 1;
        const worldMousePos2 = m4.transformPoint(invWorldViewProjection, screenMousePos);

        let minDist = 1.0;
        let minIndex = undefined;
        for (let i = 0; i < mesh.vertexCount; ++i) {
            let dist = M.lineToPointDistance(worldMousePos1, worldMousePos2, mesh.getPosition(i));
            if (dist < minDist) {
                minDist = dist;
                minIndex = i;
            }
        }
        if (minIndex !== undefined) {
            let pos = mesh.getPosition(minIndex);
            text.innerHTML = `[#${minIndex}] (${pos[0]}, ${pos[1]}, ${pos[2]})`;

            let lines = new Lines();
            let i1 = lines.addVertex(pos, rgb(0, 0, 0));
            let i2 = lines.addVertex(v3.mulScalar(pos, 100), rgb(0, 0, 0));
            lines.addLine(i1, i2);
            const bufferInfo2 = twgl.createBufferInfoFromArrays(gl, lines.arrays);
            gl.useProgram(debugDisplayProgramInfo.program);
            twgl.setBuffersAndAttributes(gl, debugDisplayProgramInfo, bufferInfo2);
            twgl.setUniforms(debugDisplayProgramInfo, uniforms);
            twgl.drawBufferInfo(gl, bufferInfo2, gl.LINES);
            gl.enable(gl.DEPTH_TEST);
        }
        else {
            text.innerHTML = '';
        }

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
</script>

</html>