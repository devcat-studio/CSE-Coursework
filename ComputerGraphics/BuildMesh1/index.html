<!DOCTYPE html>
<html>

<head>
    <meta charset="utf8">
    <!--
    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title></title>
    <style>
        body {
            margin: 0;
            font-family: monospace;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #text {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 2;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="text" style='background:#efefef;'></div>
</body>

<script id="vsDebugDisplay" type="notjs">
    uniform mat4 u_worldViewProjection;
    attribute vec4 position;
    attribute vec3 color;
    varying vec4 v_color;

    void main() {
        v_color = vec4(color.rgb, 1.0);
        gl_Position = u_worldViewProjection * position;
    }
</script>
<script id="fsDebugDisplay" type="notjs">
    precision mediump float;
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }
</script>

<!------------------- 소스 코드 ------------------->
<script type="module">
    import * as twgl from '../twgl-full.module.js';
    import { Mesh, Lines, lineToPointDistance, rgba } from './Helper.mjs';
    import { Homework } from './Homework.mjs';
    import * as shader from './Shader.mjs';
    
    const m4 = twgl.m4; // https://twgljs.org/docs/module-twgl_m4.html
    const v3 = twgl.v3; // https://twgljs.org/docs/module-twgl_v3.html
    const gl = document.querySelector("#canvas").getContext("webgl");
    const text = document.querySelector("#text");
    const programInfo = shader.createProgramInfo(gl);
    const debugDisplayProgramInfo = twgl.createProgramInfo(gl, ["vsDebugDisplay", "fsDebugDisplay"]);

    let homework = new Homework();
    const mesh = homework.buildMesh();
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, mesh.arrays);

    const screenMousePos = v3.create(1000, 0, -1);
    gl.canvas.addEventListener('mousemove', (e) => {
        const rect = gl.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        screenMousePos[0] = x / rect.width * 2 - 1;
        screenMousePos[1] = y / rect.height * -2 + 1;
    });

    const uniforms = {
    };

    function render(time) {
        time *= 0.001;
        twgl.resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const fov = 45 * Math.PI / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100;
        const projection = m4.perspective(fov, aspect, zNear, zFar);
        const eye = [2, 8, -12];
        const target = [0, 0, 0];
        const up = [0, 1, 0];

        const world = m4.rotationY(time * homework.getRotateSpeed());
        const camera = m4.lookAt(eye, target, up);
        const view = m4.inverse(camera);
        const viewProjection = m4.multiply(projection, view);
        const worldViewProjection = m4.multiply(viewProjection, world);
        const invWorldViewProjection = m4.inverse(worldViewProjection);
        const invWorld = m4.inverse(world);

        uniforms.u_viewInverse = camera;
        uniforms.u_world = world;
        uniforms.u_worldInverseTranspose = m4.transpose(invWorld);
        uniforms.u_worldViewProjection = worldViewProjection;

        // 메시를 그린다
        gl.useProgram(programInfo.program);
        twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
        twgl.setUniforms(programInfo, uniforms);
        gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);

        // 마우스 커서는 2차원 화면에서의 점 하나를 나타내는데
        // 이것을 3차원 공간으로 옮기면 선이 된다.
        // 선에서 가장 가까운 버텍스를 찾자.
        screenMousePos[2] = -1;
        const worldMousePos1 = m4.transformPoint(invWorldViewProjection, screenMousePos);
        screenMousePos[2] = 1;
        const worldMousePos2 = m4.transformPoint(invWorldViewProjection, screenMousePos);

        let minDist = 1.0;
        let minIndex = undefined;
        for (let i = 0; i < mesh.vertexCount; ++i) {
            let dist = lineToPointDistance(worldMousePos1, worldMousePos2, mesh.getPosition(i));
            if (dist < minDist) {
                minDist = dist;
                minIndex = i;
            }
        }
        if (minIndex !== undefined) {
            let pos = mesh.getPosition(minIndex);
            text.innerHTML = `[#${minIndex}] (${pos[0]}, ${pos[1]}, ${pos[2]})`;

            let lines = new Lines();
            let i1 = lines.addVertex(pos, rgba(0, 0, 0, 0.3));
            let i2 = lines.addVertex(v3.mulScalar(pos, 100), rgba(0, 0, 0, 0.3));
            lines.addLine(i1, i2);

            const linesBufferInfo = twgl.createBufferInfoFromArrays(gl, lines.arrays);
            gl.disable(gl.DEPTH_TEST);
            gl.useProgram(debugDisplayProgramInfo.program);
            twgl.setBuffersAndAttributes(gl, debugDisplayProgramInfo, linesBufferInfo);
            twgl.setUniforms(debugDisplayProgramInfo, uniforms);
            twgl.drawBufferInfo(gl, linesBufferInfo, gl.LINES);
            gl.enable(gl.DEPTH_TEST);
        }
        else {
            text.innerHTML = '';
        }

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
</script>

</html>